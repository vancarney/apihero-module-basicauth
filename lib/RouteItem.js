// Generated by CoffeeScript 1.9.3
var RouteItem, _, fs, path;

fs = require('fs-extra');

path = require('path');

_ = require('lodash')._;

RouteItem = (function() {
  function RouteItem(route_item) {
    this.route_item = route_item;
  }

  RouteItem.prototype.save = function(callback) {
    var p;
    if (!((callback != null) && typeof callback === 'function')) {
      throw 'callback required';
    }
    return fs.ensureDir(path.dirname(p = this.route_item.route_file), (function(_this) {
      return function(e) {
        if (e != null) {
          return callback.apply(_this, arguments);
        }
        return fs.writeFile(p + ".js", _this.template(_this.route_item), {
          flag: 'wx+'
        }, function(e) {
          if (e != null) {
            callback.apply(_this, arguments);
          }
          return fs.writeFile(p + ".json", JSON.stringify(_this.route_item, null, 2), {
            flag: 'wx+'
          }, function(e) {
            return callback.apply(_this, arguments);
          });
        });
      };
    })(this));
  };

  return RouteItem;

})();

RouteItem.prototype.template = _.template("/**\n * <%= name %>.js\n * Route Handler File\n * Generated by Jade-Router for ApiHero \n */\nvar _ = require('lodash');\nvar _app_ref;\nvar config = require('./<%= name %>.json');\nvar render = function(res, model) {\n  res.render( config.template_file, model, function(e,html) {\n    if (e !== null) console.log(e);\n    res.send(html);\n  }); \n};\n\nvar <%= name %>Handler = function(req, res, next) {\n  // attempts to determine name for `Query Method` defaults to 'find'\n  var funcName = config.queryMethod || 'find';\n\n  // attempts to determine `Collection Name` defaults to config name for route\n  var collectionName = (( name = config.collectionName) == \"\") ? null : name;\n\n  // placeholds the result object\n  var model = {\n    meta : []\n  };\n\n  // tests for Collection Name\n  if (collectionName == null && _app_ref.models.hasOwnProperty(collectionName) == false)\n    // renders page and returns if no Collection Name was defined\n    return render(res, model);\n\n  // performs Query Execution\n  var execQuery = function(colName, funName, q, cB) {\n\n    // tests for existance of query arguments defintion\n    if (q.hasOwnProperty('arguments')) {\n      // captures values of argument properties\n      var args = _.values(q.arguments);\n      // pushes callback into argument values array\n      args.push(cB);\n\n      // applies arguments array with callback upon Collection Operation\n      return _app_ref.models[colName][funName].apply(this, args);\n    }\n\n    // invokes Collection Operation with Query and Callback only\n    return _app_ref.models[colName][funName](q, cB);\n  };\n\n  var operateOnResults = function(op, data, callback) {\n    if (callback == null || typeof callback != 'function')\n      throw \"callback required\";\n\n    // tests for Object as op argument\n    if (op == null || typeof op != 'object')\n      // returns on callback if operation is invalid\n      return callback(\"operation object was invalid\");\n\n    // defines missing and fields Arrays\n    var missing, fields = ['fieldName', 'opType', 'dataType', 'call'];\n\n    // tests to ensure all required fields exist in object\n    if (( missing = _.difference(fields, _.keys(op)) ).length > 0)\n      // returns on callback if any field was missing\n      return callback(\"operation object was missing required parameter '\" + missing[0] + \"'\");\n      \n    var doOp = function(op, record, callback) {\n      // console.log(arguments);\n      if (op.opType == 'append' && record.hasOwnProperty(op.fieldName))\n        return callback(null, record);\n        \n      // derives callee method based on `on` parameter or from `helpers` object\n      var _callee = (op.call.hasOwnProperty('on')) ? record[op.call.on] || null : global.helpers || {};\n      \n      // returns with callback if `on` parameter is defined and _callee unset\n      if (op.call.hasOwnProperty('on') && _callee == null)\n        return callback(null, record);\n      \n      // resets _callee with value of function if _callee is function\n      if (typeof  _callee == 'function')\n         _callee = _callee();\n      \n      // tests _callee for method reference\n      if (_callee.hasOwnProperty(op.call.method)) {\n        \n        // tests if method reference is a function\n        if (typeof _callee[op.call.method] == 'function') {\n          \n          // tests if call settings has a `with` parameter defined\n          if (op.call.hasOwnProperty('with')) {\n            \n            // obtains Array of values from record values\n            _with = _.map(op.call['with'], function(col) { return record[col]; });\n            \n            // invokes method with arguments passed from  values in `with`\n            record.__data[op.fieldName] = _callee[op.call.method].apply( _callee, _with);\n            \n            // returns with callback\n            return callback(null, record);\n          }\n          \n          // invokes mthod directly with no arguments\n          record.__data[op.fieldName] = _callee[op.call.method].call( _callee );\n          \n          // returns with callback\n          return callback(null, record);\n        }\n\n        // sets directly with value of method parameter\n        record.__data[op.fieldName] = _callee[op.call.method];\n        \n        // returns with callback\n        return callback(null, record);\n      }\n      \n      // attempts to set with default value\n      if (op.hasOwnProperty('default')) {\n        record.__data[op.fieldName] = op['default'];\n        \n        // returns with callback\n        return callback(null, record);\n      } \n      \n      // sets field to null as fallback\n      record.__data[op.fieldName] = null;\n      \n      // returns with callback\n      return callback(null, record);\n    };\n\n    // tests if dataset is array\n    if (_.isArray(data)) {\n      \n      // handles callbacks  to emit only after completed\n      var done = _.after(data.length, callback);\n      _.each(data, function(record) {\n        // invokes doOp for each record\n        doOp(op, record, done);\n      });\n    } else {\n      // invokes doOp for result\n      doOp(op,data, function() { callback(null); });\n    }\n\n  };\n\n  // processes query from Configuration and Request Query and Params Object\n  var processQuery = function(c_query, callback) {\n\n    // holds `name` of Response Object Element\n    var elName = c_query.hasOwnProperty('name') ? c_query.name : 'results';\n\n    // holds `name` of Collection to perform Operations against\n    var colName = c_query.hasOwnProperty('collectionName') ? c_query.collectionName : collectionName;\n\n    // holds `name` of Operation to perform against Collection\n    var funName = c_query.hasOwnProperty('queryMethod') ? c_query.queryMethod : (funcName || 'find');\n\n    // checks for Required Arguments property set on Query config\n    if (c_query.query.hasOwnProperty('required') && _.isArray(c_query.query.required)) {\n      // holds missing arguments that were required\n      var missing;\n      // checks for existance of all required arguments\n      if (( missing = _.difference(c_query.query.required, _.keys(req.query))).length > 0)\n        // returns user error if missing a required argument\n        return res.status(400).send(\"required argument '\" + missing[0] + \"' was missing from query params\");\n    }\n\n    // tests for arguments element on Query Settings Object\n    if (c_query.query.hasOwnProperty('arguments')) {\n\n      // loops on each arguments defined\n      for (arg in c_query.query.arguments) {\n\n        // skips unprocessable arguments\n        if (!c_query.query.arguments[arg])\n          continue;\n\n        // tests for argument values that match `:` or `?`\n        if (( param = c_query.query.arguments[arg].match(/^(\\:|\\?)+([a-zA-Z0-9-_]{1,})+$/)) != null) {\n          // if value matched `:`, that is a ROUTE PARAMETER such as /:id and is applied against request.params\n          // if value matched `?`, that is a REQUEST QUERY PARAMETER such as ?param=value and is applied against request.query\n          c_query.query.arguments[arg] = req[(param[1] === ':' ? 'params' : 'query')]['' + param[2]];\n        }\n      }\n    }\n\n    // wraps passed calllback for negotiation\n    var cB = function(e, res) {\n      if (e != null) {\n        // invokes callback and returns in case of error\n        return callback(e);\n      }\n\n      // placeholds results object\n      var o = {};\n\n      // applies defined Result Element Name withj results\n      o[elName] = res;\n      \n      if (c_query.hasOwnProperty('operations')) {\n        // tests if operations parameter is of type Array\n        if (!_.isArray(c_query.operations))\n          // transforms operations parameter fr om Object to Array\n          c_query.operations = [c_query.operations];\n          \n        var done = _.after(c_query.operations.length, function() {\n          callback(null, o); });\n        _.each(c_query.operations, function(op) {\n          operateOnResults(op, o[elName], done);\n        });\n      } \n      \n      else {\n        // passes formatted results to callback\n        callback(null, o);\n      }\n    };\n\n    // invokes Query Execution Method with Collection, Operation Method and Query\n    execQuery(colName, funName, c_query.query, cB);\n  };\n\n  // tests if configured Query element is an `Array`\n  if (_.isArray(config.query)) {\n    // defines completion method\n    var done = _.after(config.query.length, function(e, resultset) {\n      if (e != null) {\n        console.log(e);\n        return res.sendStatus(500);\n      }\n      // invokes render with result set\n      render(res, resultset);\n    });\n\n    // loops on each configured query passed\n    _.each(config.query, function(q) {\n      // inokes Query Processing method\n      processQuery(_.cloneDeep(q), function(e, res) {\n        // invokes done each iteration\n        done(e, _.extend(model, res));\n      });\n    });\n  } else {\n\n    // is a single query configuration -- process directly\n    processQuery(_.cloneDeep(config.query), function(e, resultset) {\n      if (e != null) {\n        console.log(e);\n        return res.sendStatus(500);\n      }\n\n      // invokes render with result set\n      render(res, _.extend(model, resultset));\n    });\n  }\n\n};\n\n// Routeing Module Entry Point\nmodule.exports.init = function(app) {\n  // holds reference to Application\n  _app_ref = app;\n  // tests for RegExp based route as denoted by a `rx:` prefix\n  var route = (s = config.route.split('rx:')).length > 1 ? new RegExp(s.pop()) : config.route;\n  // applies the Route and Handler Method to a GET Request \n  app.get(route, <%= name %>Handler);\n};");

module.exports = RouteItem;
